#!/usr/bin/env perl
## Copyright Â© 2011 by Daniel Friesel <derf@finalrewind.org>
## License: WTFPL:
##   0. You just DO WHAT THE FUCK YOU WANT TO.
use strict;
use warnings;
use 5.010;
use autodie;

use Crypt::CBC;
use Crypt::Eksblowfish;
use Crypt::Eksblowfish::Bcrypt qw(bcrypt_hash en_base64 de_base64);
use File::Path qw(make_path);
use File::Slurp qw(slurp write_file);
use POSIX;

my $VERSION = '0.1';

my %state = (
	cost => 12,
	salt => new_salt(),
);

my ($action, @args) = @ARGV;

sub cmd_add {
	my ($name) = @_;
	my $init = get_xdg_config_file('init');
	my $store = get_xdg_data_file($name);
	my $pass;

	if (-e $store) {
		die("This password name already exists\n");
	}

	my $cipher;
	my $password;

	$password = get_password();
	undef %state;
	load_state_from($init);
	$state{'salt'} = new_salt();
	$state{'cost'} //= 12;

	$state{'url'} = read_input(
		prefix => 'URL'
	);
	$state{'login'} = read_input(
		prefix => 'Login'
	);
	$state{'extra'} = read_input(
		prefix => 'Extra'
	);
	$pass = read_input(
		prefix => 'Password',
		invisible => 1,
		verify => 1,
	);

	$cipher = setup_cipher($password);

	$state{'hash'} = $cipher->encrypt_hex($pass);

	save_state_to($store);

	return;
}

sub cmd_dump {
	my ($name) = @_;
	my $store = get_xdg_data_file($name);
	my $password;
	my $cipher;

	if (not -e $store) {
		die("No such password\n");
	}

	$password = get_password();
	load_state_from($store);
	$cipher = setup_cipher($password);

	printf(
		"%-8s : %s\n" x 4,
		'URL'     , $state{'url'},
		'Login'   , $state{'login'},
		'Extra'   , $state{'extra'} // q{},
		'Password', $cipher->decrypt_hex($state{'hash'}),
	);

	return;
}

sub cmd_get {
	my ($name) = @_;
	my $store = get_xdg_data_file($name);
	my $password;
	my $cipher;

	if (not -e $store) {
		die("No such password\n");
	}

	$password = get_password();
	load_state_from($store);

	$cipher = setup_cipher($password);

	to_clipboard($cipher->decrypt_hex($state{'hash'}));

	return;
}

sub cmd_info {
	my ($name) = @_;
	my $store = get_xdg_data_file($name);

	if (not -e $store) {
		die("No such password\n");
	}

	load_state_from($store);

	printf(
		"%-8s : %s\n" x 3,
		'URL'  , $state{'url'},
		'Login', $state{'login'},
		'Extra', $state{'extra'},
	);
	return;
}

sub cmd_list {
	opendir(my $dh, get_xdg_data_file());
	my @entries = grep { /^[^.]/ } readdir($dh);
	closedir($dh);

	for my $file (sort @entries) {
		say $file;
	}
}

sub create_dot_dirs {
	make_path(get_xdg_config_file());
	make_path(get_xdg_data_file());
	return;
}

sub create_pass {
	my ($passfile) = @_;
	my $pass;
	my $hash;

	say 'raps2 was never run before. Please set master password first.';
	$pass = read_input(
		prefix => 'Password',
		invisible => 1,
		verify => 1,
	);

	$hash = en_base64(bcrypt_hash({
			key_nul => 1,
			cost => $state{'cost'},
			salt => $state{'salt'},
		}, $pass));
	write_file(
		$passfile,
		"cost $state{cost}\n",
		"salt $state{salt}\n",
		"hash $hash\n",
	);

	return $pass;
}

sub get_password {
	my $pass;
	my $passfile = get_xdg_config_file('password');

	if (not -e $passfile) {
		 return create_pass($passfile);
	}

	load_state_from($passfile);
	$pass = read_input(
		prefix => 'Master password',
		invisible => 1,
	);
	if (en_base64(bcrypt_hash({
				key_nul => 1,
				cost => $state{'cost'},
				salt => $state{'salt'},
			}, $pass)) ne $state{'hash'}) {
		die("Invalid passphrase\n");
	}

	return $pass;
}

sub get_xdg_config_file {
	my ($file) = @_;
	my $env    = $ENV{'XDG_CONFIG_HOME'};
	my $home   = $ENV{'HOME'};

	$file //= q{};
	$env  //= "${home}/.config";

	return "${env}/raps2/${file}";
}

sub get_xdg_data_file {
	my ($file) = @_;
	my $env    = $ENV{'XDG_DATA_HOME'};
	my $home   = $ENV{'HOME'};

	$file //= q{};
	$env  //= "${home}/.local/share";

	return "${env}/raps2/${file}";
}

sub load_state_from {
	my ($file) = @_;

	if (not -e $file) {
		return;
	}

	for my $line (slurp($file)) {
		my ($key, $value) = split(qr{\s+}, $line);

		if (not ($key and $value)) {
			next;
		}

		$state{$key} = $value;
	}
	return;
}

sub new_salt {
	my $salt = q{};

	for (1 .. 16) {
		$salt .= chr(0x21 + int(rand(90)));
	}

	return $salt;
}

sub save_state_to {
	my ($file) = @_;
	my $raw = q{};

	while (my ($key, $value) = each(%state)) {
		$raw .= "${key} ${value}\n";
	}

	write_file($file, $raw);
	return;
}

sub setup_cipher {
	my ($password) = @_;

	my $eksblowfish = Crypt::Eksblowfish->new(
		$state{'cost'},
		$state{'salt'},
		$password,
	);
	return Crypt::CBC->new(-cipher => $eksblowfish);
}

sub to_clipboard {
	my ($pw) = @_;

	open(my $clipboard, '|-', 'xclip -l 1');
	print $clipboard $pw;
	close($clipboard);
	return;
}

sub read_input {
	my %opts = @_;
	my ($prefix, $invisible, $verify)
		= @opts{'prefix', 'invisible', 'verify'};
	my $term = POSIX::Termios->new();
	my ($input1, $input2);

	if ($invisible) {
		$term->getattr(0);
		$term->setlflag($term->getlflag() & ~POSIX::ECHO);
		$term->setattr(0, POSIX::TCSANOW);
	}

	print "${prefix}: ";
	$input1 = readline(STDIN);

	if ($invisible) {
		print "\n";
	}

	if ($verify) {
		print 'Verify: ';
		$input2 = readline(STDIN);

		if ($invisible) {
			print "\n";
		}
	}

	if ($invisible) {
		$term->setlflag($term->getlflag() | POSIX::ECHO);
		$term->setattr(0, POSIX::TCSANOW);
	}

	if ($verify and $input1 ne $input2) {
		die("Lines do not match\n");
	}

	chomp $input1;
	return $input1;
}

create_dot_dirs();

given ($action) {
	when ('add')  { cmd_add(@args) }
	when ('dump') { cmd_dump(@args) }
	when ('get')  { cmd_get(@args) }
	when ('info') { cmd_info(@args) }
	when ('list') { cmd_list(@args) }
}

__END__

=head1 NAME

raps2 - "Right, Another Password Store" take two

=head1 SYNOPSIS

B<raps2> I<action> I<args ...>

=head1 DESCRIPTION

raps2 is a simple password safe.  You give it a name, a password and optional
metadata, and it will encrypt and store them for you.  You probably want to
start with C<< raps2 add accountname >>, and then later use C<< raps2 get
accountname >> and paste the corresponding password into whatever application
requires it.  B<raps2> will automatically initialize its store when used for
the first time.

=head1 ACTIONS

=over

=item B<add> I<account>

Adds I<account> to the store.  It will ask you for the store's master
password, some metadata and the new password and then store them.  Note that
only the password is encrypted, the metadata is saved as clear-text.

=item B<dump> I<account>

Dump everything saved for I<account>, including the clear-text password, to
stdout.

=item B<get> I<account>

Decrypt I<account>'s password and store it in the X Clipboard.  Note that it
can only be pasted once.

=item B<info> I<account>

Show information about I<account>, does not require the master password.

=back

=head1 EXIT STATUS

zero on success, non-zero otherwise.

=head1 CONFIGURATION

None so far.

=head1 DEPENDENCIES

=over

=item * Crypt::CBC

=item * Crypt::Eksblowfish

=item * File::Path (usually included with perl core)

=item * File::Slurp

=back

=head1 BUGS AND LIMITATIONS

This is alpha software, the store format may change without further notice.
Backwards-compatibility is not guaranteed.

=head1 AUTHOR

Copyright (C) 2011 by Daniel Friesel E<lt>derf@finalrewind.orgE<gt>

=head1 LICENSE

  0. You just DO WHAT THE FUCK YOU WANT TO.
